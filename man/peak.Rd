% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/peak.R
\name{peak}
\alias{peak}
\title{Test purrr's iterator functions on a subset of input elements}
\usage{
peak(expr, i = 1L, simplify = TRUE)
}
\arguments{
\item{expr}{A function call to a \code{{purrr}} iterator function. See the "Supported functions"
section below for an overview of which \code{{purrr}} iterator functions are currently supported.}

\item{i}{index specifying elements to extract or replace. Only numeric or character vectors are
excepted. When numeric, the values have to be all positive or all negative. Neither numeric vectors
mixing positive and negative numbers nor lists mixing numeric and character element can be used
for subsetting.}

\item{simplify}{When \code{TRUE} (the default) and when \code{i} is of length one, \code{peak()} will \code{unname}
and \code{unlist} the output object. When \code{FALSE} the output object is return as is.}
}
\value{
A subset of the output of the original function call to a \code{{purrr}} iterator function. When
the output is of length one and \code{simplify = TRUE} the output object will be unnamed and unlisted.

When the input iterator function is \code{\link[purrr:reduce]{purrr::reduce()}} or \code{\link[purrr:reduce]{purrr::reduce2()}} and \code{i} selects more
than one element, all selected elements are returned (unlike the originial \code{reduce} call which
always return the last element only)
}
\description{
\code{peak()} takes a function call to one of \code{{purrr}}'s iterator functions, such as \code{\link[purrr:map]{purrr::map()}},
and tests if the function call can be run on a selected subset \code{i} of input elements
(\code{.x}, \code{.y} or \code{.l}). Without further arguments \code{peak()} will always test the first input
element(s) (\code{i = 1}).

\code{peak()} will modify the iterator function call so that it is only applied to the selected elements
in \code{i}. This means, errors that might occur in non-selected elements will not be thrown, since
the input elements are subsetted before the evaluation of the function call.

\code{peak()} will also adjust all index elements of the original call to reproduce the same output,
as if the output had been subsetted by \code{i} after the function call has been evaluated.
For example the \code{.at} argument in \code{\link[purrr:map_if]{purrr::map_at()}} or the \code{.y} object in the \code{.f} argument
of \code{\link[purrr:imap]{purrr::imap()}}. See the example section for more details.
}
\section{Supported functions}{


The following iterator functions from the \code{{purrr}} package are currently supported:

\if{html}{\out{<div class="sourceCode r">}}\preformatted{get_supported_fns("peak")
#> No supported functions. Did you specify the function name correctly?
}\if{html}{\out{</div>}}
}

\section{Examples}{

If called without arguments, \code{peak()} will subset the first element. It will further
unname and unnest the output. We can prevent this behavior by using \code{simplify = FALSE}.
If \code{i} is of length greater than one, the output will never be unnamed and unlisted.

\if{html}{\out{<div class="sourceCode {r, comment = "#>", collapse = TRUE}">}}\preformatted{a <- list(a = 1:3, b = 4:6, c = 7:9)

map(a, sum) \%>\% peak()

map(a, sum) \%>\% peak(simplify = FALSE)

map(a, sum) \%>\% peak(c(1,3))
}\if{html}{\out{</div>}}

\code{peak()} subsets the input elements before evaluating the call. So errors in non-selected
elements won't be thrown. Compare:

\if{html}{\out{<div class="sourceCode {r, comment = "#>", collapse = TRUE, error = TRUE}">}}\preformatted{b <- list(a = 1:3, b = letters[4:6], c = 7:9)

map(b, sum)

map(b, sum) \%>\% peak(c(1, 3))
}\if{html}{\out{</div>}}

Used on a simple call to \code{\link[purrr:map]{purrr::map()}} \code{peak()} does nothing more than subsetting the \code{.x} argument
before evaluating the call. When used on \code{\link[purrr:map_if]{purrr::map_at()}} or \code{\link[purrr:imap]{purrr::imap()}} \code{peak()} will adjust
all index elements to produce a result as if the output of the call had been subsetted.

\if{html}{\out{<div class="sourceCode {r, comment = "#>", collapse = TRUE, error = TRUE}">}}\preformatted{a <- list(a = 1:3, b = 4:6, c = 7:9)

map(a, sum) \%>\% peak(2)

# the above is the same as
map(a[2], sum)

# this doesn't hold true for `map_at()` or `imap()`:
map_at(a, .at = 2, sum)

# this works correctly
map_at(a, .at = 2, sum) \%>\% peak(2)

# this doesn't throw an error, ...
# but applies `sum` to a non existing element, returning `a[2]` as is:
map_at(a[2], .at = 2, sum)


# the same holds for `imap()`:
b <- unname(a)
imap(b, ~ paste(.y, ":", sum(.x)))

# returns the second element of above's call
imap(b, ~ paste(.y, ":", sum(.x))) \%>\% peak(2)

# while `sum(.x)` corresponds to the second element ...
# the index in why `.y` has changed:
imap(b[2], ~ paste(.y, ":", sum(.x)))
}\if{html}{\out{</div>}}

Using \code{peak()} on \code{\link[purrr:reduce]{purrr::reduce()}} and \code{\link[purrr:reduce]{purrr::reduce2()}} is a special case, for two reasons:
\enumerate{
\item We can select more than one element in \code{i} and all selected elements will be returned
(usually \code{reduce} only returns the last element of the iteration).
\item Since each element depends on the preceding output element, \code{peak()} will evaluate all
needed elements to produce the desired output, even if they haven't been selected.
}

The second point also applies to \code{\link[purrr:accumulate]{purrr::accumulate()}} and \code{\link[purrr:accumulate]{purrr::accumulate2()}}.

The following example should illustrate both points:

\if{html}{\out{<div class="sourceCode {r, comment = "#>", collapse = TRUE, error = TRUE}">}}\preformatted{a <- as.list(1:10)

reduce(a, ~ sum(.x, .y))

# This will return and evaluate the first element only
reduce(a, ~ sum(.x, .y)) \%>\% peak()

# This will evaluate element 1 to 3 but only return 2 and 3
reduce(a, ~ sum(.x, .y)) \%>\% peak(c(2,3))

b <- c(as.list(1:3), "d", as.list(5:7))

# only evaluated the first three elements (no problem)
reduce(b, ~ sum(.x, .y)) \%>\% peak(c(1, 3))

# evaluates elements 2 to 5, an error eccours in element 4
reduce(b, ~ sum(.x, .y)) \%>\% peak(c(2, 5))
}\if{html}{\out{</div>}}
}

